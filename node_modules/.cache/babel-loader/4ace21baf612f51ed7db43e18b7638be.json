{"ast":null,"code":"function Calculate(state, button_name) {\n  if (button_name == \"C\") {\n    return {\n      input: \"\",\n      op: \"\",\n      next: \"\"\n    };\n  }\n\n  if (!isNaN(parseInt(buttonName))) {\n    if (button_name == \"0\" && state.next == \"0\") {\n      return {};\n    }\n\n    if (state.op) {\n      if (state.next) {\n        return {\n          next: obj.next + buttonName\n        };\n      }\n\n      return {\n        next: buttonName\n      };\n    } // If there is no operation, update next and clear the value\n\n\n    if (obj.next) {\n      const next = obj.next === \"0\" ? buttonName : obj.next + buttonName;\n      return {\n        next,\n        total: null\n      };\n    }\n\n    return {\n      next: buttonName,\n      total: null\n    };\n  }\n\n  if (buttonName === \"%\") {\n    if (obj.operation && obj.next) {\n      const result = operate(obj.total, obj.next, obj.operation);\n      return {\n        total: Big(result).div(Big(\"100\")).toString(),\n        next: null,\n        operation: null\n      };\n    }\n\n    if (obj.next) {\n      return {\n        next: Big(obj.next).div(Big(\"100\")).toString()\n      };\n    }\n\n    return {};\n  }\n\n  if (buttonName === \".\") {\n    if (obj.next) {\n      // ignore a . if the next number already has one\n      if (obj.next.includes(\".\")) {\n        return {};\n      }\n\n      return {\n        next: obj.next + \".\"\n      };\n    }\n\n    return {\n      next: \"0.\"\n    };\n  }\n\n  if (buttonName === \"=\") {\n    if (obj.next && obj.operation) {\n      return {\n        total: operate(obj.total, obj.next, obj.operation),\n        next: null,\n        operation: null\n      };\n    } else {\n      // '=' with no operation, nothing to do\n      return {};\n    }\n  }\n\n  if (buttonName === \"+/-\") {\n    if (obj.next) {\n      return {\n        next: (-1 * parseFloat(obj.next)).toString()\n      };\n    }\n\n    if (obj.total) {\n      return {\n        total: (-1 * parseFloat(obj.total)).toString()\n      };\n    }\n\n    return {};\n  } // Button must be an operation\n  // When the user presses an operation button without having entered\n  // a number first, do nothing.\n  // if (!obj.next && !obj.total) {\n  //   return {};\n  // }\n  // User pressed an operation button and there is an existing operation\n\n\n  if (obj.operation) {\n    return {\n      total: operate(obj.total, obj.next, obj.operation),\n      next: null,\n      operation: buttonName\n    };\n  } // no operation yet, but the user typed one\n  // The user hasn't typed a number yet, just save the operation\n\n\n  if (!obj.next) {\n    return {\n      operation: buttonName\n    };\n  } // save the operation and shift 'next' into 'total'\n\n\n  return {\n    total: obj.next,\n    next: null,\n    operation: buttonName\n  };\n  /*\n  if(button_name==\"C\"){\n      return {input:\"\"}\n  }\n  \n  if(button_name.includes(\"op\")){\n      op = button_name.split('op_')[1]\n      return {input:input, op:op, temp:input+op}\n  }\n   if(button_name==\".\"){\n      return {input:input+button_name,op:\"0\"}\n  }\n   if(!isNaN(parseInt(button_name))){//when click the number button\n      if(isNaN(parseInt(op))){ //op is operator not number\n          input = parseFloat(input)\n          console.log(temp)\n          temp = temp.split(op)[0]\n          console.log(temp)\n          switch(op){\n              case \"+\":\n              case \"-\":\n              case \"*\":\n              case \"/\":\n          }\n          return {input:\"\"}\n      }\n      return {input:input+button_name, op:\"0\",}\n  }\n  */\n}\n\nexport default Calculate;","map":{"version":3,"sources":["/home/parkji/react_calculator/src/Calculate.js"],"names":["Calculate","state","button_name","input","op","next","isNaN","parseInt","buttonName","obj","total","operation","result","operate","Big","div","toString","includes","parseFloat"],"mappings":"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","sourcesContent":["function Calculate(state,button_name){\n    if (button_name == \"C\") {\n        return {\n          input: \"\",\n          op: \"\",\n          next: \"\",\n        };\n      }\n    \n      if (!isNaN(parseInt(buttonName))) {\n        if (button_name == \"0\" && state.next == \"0\") {\n          return {};\n        }\n\n        if (state.op) {\n          if (state.next) {\n            return { next: obj.next + buttonName };\n          }\n          return { next: buttonName };\n        }\n        // If there is no operation, update next and clear the value\n        if (obj.next) {\n          const next = obj.next === \"0\" ? buttonName : obj.next + buttonName;\n          return {\n            next,\n            total: null,\n          };\n        }\n        return {\n          next: buttonName,\n          total: null,\n        };\n      }\n    \n      if (buttonName === \"%\") {\n        if (obj.operation && obj.next) {\n          const result = operate(obj.total, obj.next, obj.operation);\n          return {\n            total: Big(result)\n              .div(Big(\"100\"))\n              .toString(),\n            next: null,\n            operation: null,\n          };\n        }\n        if (obj.next) {\n          return {\n            next: Big(obj.next)\n              .div(Big(\"100\"))\n              .toString(),\n          };\n        }\n        return {};\n      }\n    \n      if (buttonName === \".\") {\n        if (obj.next) {\n          // ignore a . if the next number already has one\n          if (obj.next.includes(\".\")) {\n            return {};\n          }\n          return { next: obj.next + \".\" };\n        }\n        return { next: \"0.\" };\n      }\n    \n      if (buttonName === \"=\") {\n        if (obj.next && obj.operation) {\n          return {\n            total: operate(obj.total, obj.next, obj.operation),\n            next: null,\n            operation: null,\n          };\n        } else {\n          // '=' with no operation, nothing to do\n          return {};\n        }\n      }\n    \n      if (buttonName === \"+/-\") {\n        if (obj.next) {\n          return { next: (-1 * parseFloat(obj.next)).toString() };\n        }\n        if (obj.total) {\n          return { total: (-1 * parseFloat(obj.total)).toString() };\n        }\n        return {};\n      }\n    \n      // Button must be an operation\n    \n      // When the user presses an operation button without having entered\n      // a number first, do nothing.\n      // if (!obj.next && !obj.total) {\n      //   return {};\n      // }\n    \n      // User pressed an operation button and there is an existing operation\n      if (obj.operation) {\n        return {\n          total: operate(obj.total, obj.next, obj.operation),\n          next: null,\n          operation: buttonName,\n        };\n      }\n    \n      // no operation yet, but the user typed one\n    \n      // The user hasn't typed a number yet, just save the operation\n      if (!obj.next) {\n        return { operation: buttonName };\n      }\n    \n      // save the operation and shift 'next' into 'total'\n      return {\n        total: obj.next,\n        next: null,\n        operation: buttonName,\n      };\n\n\n    /*\n    if(button_name==\"C\"){\n        return {input:\"\"}\n    }\n    \n    if(button_name.includes(\"op\")){\n        op = button_name.split('op_')[1]\n        return {input:input, op:op, temp:input+op}\n    }\n\n    if(button_name==\".\"){\n        return {input:input+button_name,op:\"0\"}\n    }\n\n    if(!isNaN(parseInt(button_name))){//when click the number button\n        if(isNaN(parseInt(op))){ //op is operator not number\n            input = parseFloat(input)\n            console.log(temp)\n            temp = temp.split(op)[0]\n            console.log(temp)\n            switch(op){\n                case \"+\":\n                case \"-\":\n                case \"*\":\n                case \"/\":\n            }\n            return {input:\"\"}\n        }\n        return {input:input+button_name, op:\"0\",}\n    }\n    */\n}\n\nexport default Calculate;"]},"metadata":{},"sourceType":"module"}